defmodule TypeCheck.Type.StreamData do
  @moduledoc """
  Transforms types into StreamData generators.

  With the exception of `wrap_with_gen/2`,
  methods in this module are
  only compiled when the optional dependency
  `:stream_data` is added to your project's dependencies.
  """

  defstruct [:type, :generator_function]

  @doc """
  Customizes a type with a _custom_ generator.

  `generator_function` can be a arity-zero function
  (in which case it should simply return a StreamData generator)

  or a arity-one function, in which case it is passed
  the value that would be generated by default and it can be altered
  by e.g. using `StreamData.map/2` or `StreamData.bind/2`.

  Note that these functions _must_ be of the form `&Module.function/arity`
  because this is the only form of function capture that can be stored at compile-time.

  ## Example:

      iex> defmodule IntString do
      ...>   use TypeCheck
      ...>   import TypeCheck.Type.StreamData
      ...>   @type! t() :: ((val :: binary()) when Integer.parse(val) != :error)
      ...>                 |> wrap_with_gen(&IntString.gen/0)
      ...>
      ...>   def gen() do
      ...>     StreamData.integer()
      ...>     |> StreamData.map(&to_string/1)
      ...>   end
      ...> end
      ...>
      ...> IntString.t() |> TypeCheck.Type.StreamData.to_gen() |> StreamData.seeded(42) |> Enum.take(10)
      ["0", "2", "1", "-3", "-5", "-4", "-3", "-4", "3", "-6"]
  """
  def wrap_with_gen(type, generator_function) when is_function(generator_function, 0) or is_function(generator_function, 1) do
    %__MODULE__{type: type, generator_function: generator_function}
  end

  @doc """
  Customizes a type with a _custom_ generator.

  Similar to wrap_with_gen/2 but this variant
  allows the preparation of arguments that should be passed to the to-be-called function.

  This function is expected to return either:
  - A StreamData generator.
  - An arity-1 function, which will then immediately be called,
    passing in the original StreamData generator of the type that is being wrapped.

  ## Example:


      iex> defmodule MinMaxFloatString do
      ...>   use TypeCheck
      ...>   import TypeCheck.Type.StreamData
      ...>   defmacro min_max_float(min, max) do
      ...>     quote do
      ...>        ((val :: binary()) when Float.parse(val) != :error)
      ...>        |> wrap_with_gen(MinMaxFloatString, :gen, [unquote(min), unquote(max)])
      ...>     end
      ...>   end
      ...>
      ...>   def gen(min, max) do
      ...>     StreamData.float(min: min, max: max)
      ...>     |> StreamData.map(&to_string/1)
      ...>   end
      ...> end
      ...>
      ...> defmodule Example do
      ...>   use TypeCheck
      ...>   require MinMaxFloatString
      ...>   import TypeCheck.Type.StreamData
      ...>   @type! unit :: MinMaxFloatString.min_max_float(0.0, 1.0)
      ...> end
      ...> Example.unit() |> TypeCheck.Type.StreamData.to_gen() |> StreamData.seeded(42) |> Enum.take(10)
      ["0.0", "0.5", "0.75", "0.0", "0.25", "0.75", "0.90625", "0.78125", "0.0", "0.90625"]
  """
  def wrap_with_gen(type, module, function_name, args) when is_atom(module) and is_atom(function_name) and is_list(args) do
    %__MODULE__{type: type, generator_function: {module, function_name, args}}
  end

  def wrap_with_gen(type, module = %TypeCheck.Builtin.Literal{}, function_name = %TypeCheck.Builtin.Literal{}, args = %TypeCheck.Builtin.FixedList{}) do
    wrap_with_gen(type, module.value, function_name.value, Enum.map(args.element_types, fn elem -> elem.value end))
  end
  def wrap_with_gen(t, m, f, a) do
    IO.inspect({t, m, f, a}, structs: false)
  end

  defimpl TypeCheck.Protocols.ToCheck do
    def to_check(s, param) do
      TypeCheck.Protocols.ToCheck.to_check(s.type, param)
    end
  end

  defimpl TypeCheck.Protocols.Inspect do
    def inspect(s, opts) do
      TypeCheck.Protocols.Inspect.inspect(s.type, opts)
    end
  end

  if Code.ensure_loaded?(StreamData) do

    defimpl TypeCheck.Protocols.ToStreamData do
      def to_gen(s) do
        case s.generator_function() do
          f when is_function(f, 0) ->
            f.()
          f when is_function(f, 1) ->
            s.type
            |> TypeCheck.Protocols.ToStreamData.to_gen()
            |> f.()
          {module, function_name, args} ->
            case apply(module, function_name, args) do
              fun when is_function(fun) ->
                fun.()
              res = %StreamData{} ->
                res
            end
        end
      end
    end

    @doc """
    When given a type, it is transformed to a StreamData generator
    that can be used in a property test.

        iex> import TypeCheck.Type.StreamData
        iex> generator = TypeCheck.Type.build({:ok | :error, integer()}) |> to_gen()
        iex> StreamData.seeded(generator, 42) |> Enum.take(10)
        [
        {:ok, -1},
        {:ok, 2},
        {:ok, -2},
        {:ok, -4},
        {:ok, 1},
        {:ok, 1},
        {:ok, 2},
        {:ok, 4},
        {:ok, -7},
        {:ok, 5}
        ]
    """
    def to_gen(type) do
      TypeCheck.Protocols.ToStreamData.to_gen(type)
    end

    def arbitrary_primitive_type_gen do
      choices = primitive_types_list()
      Elixir.StreamData.one_of(choices)
    end

    defp primitive_types_list() do
      import TypeCheck.Builtin

      simple =
        [
          any(),
          atom(),
          binary(),
          bitstring(),
          boolean(),
          float(),
          function(),
          integer(),
          number()
        ]
        |> Enum.map(&Elixir.StreamData.constant/1)

      lit = Elixir.StreamData.term() |> Elixir.StreamData.map(&literal/1)

      [lit | simple]
    end

    def arbitrary_type_gen() do
      # TODO WIP
      StreamData.one_of(
        primitive_types_list() ++ [list_gen(), map_gen(), fixed_list_gen(), fixed_tuple_gen()]
      )
    end

    defp list_gen() do
      lazy_type_gen()
      |> StreamData.map(&TypeCheck.Builtin.list/1)
    end

    defp map_gen() do
      {lazy_type_gen(), lazy_type_gen()}
      |> StreamData.map(fn {key_type, value_type} ->
        TypeCheck.Builtin.map(key_type, value_type)
      end)
    end

    def fixed_list_gen() do
      lazy_type_gen()
      |> StreamData.list_of()
      |> StreamData.map(&TypeCheck.Builtin.fixed_list/1)
    end

    defp fixed_tuple_gen() do
      lazy_type_gen()
      |> StreamData.list_of(max_length: 255)
      |> StreamData.map(&TypeCheck.Builtin.fixed_tuple/1)
    end

    defp lazy_type_gen() do
      # Lazily call content generator
      # To prevent infinite expansion recursion
      StreamData.constant({})
      |> StreamData.bind(fn _ ->
        arbitrary_type_gen()
      end)
    end
  end
end
